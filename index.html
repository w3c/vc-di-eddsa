<!DOCTYPE html>
<html>
  <head>
    <title>EdDSA Cryptosuite v2022</title>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <!--
      === NOTA BENE ===
      For the three scripts below, if your spec resides on dev.w3 you can check them
      out in the same tree and use relative links so that they'll work offline,
     -->
    <script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove"></script>
    <script class="remove" src="https://w3c.github.io/vc-data-integrity/common.js"></script>

    <script type="text/javascript" class="remove">
      var respecConfig = {
        // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use ED.
        specStatus: "FPWD",

        // the specification's short name, as in http://www.w3.org/TR/short-name/
        shortName: "vc-di-eddsa",
        group: "vc",

        // if you wish the publication date to be other than today, set this
        publishDate:  "2023-04-18",

        // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
        // and its maturity status
        // previousPublishDate:  "1977-03-15",
        // previousMaturity:  "WD",

        // if there a publicly available Editor's Draft, this is the link
        edDraftURI: "https://w3c.github.io/vc-di-eddsa/",
        //latestVersion: "https://www.w3.org/community/reports/credentials/CG-FINAL-di-eddsa-2020-20220724/",

        // if this is a LCWD, uncomment and set the end of its review period
        // lcEnd: "2009-08-05",

        // if you want to have extra CSS, append them to this list
        // it is recommended that the respec.css stylesheet be kept
        //extraCSS:             ["spec.css", "prettify.css"],

        // editors, add as many as you like
        // only "name" is required
        editors: [{
          name: "Manu Sporny",
          url: "https://www.linkedin.com/in/manusporny/",
          company: "Digital Bazaar",
          companyURL: "https://digitalbazaar.com/",
          w3cid: 41758
        }, {
          name: "Dmitri Zagidulin",
          url: "https://www.linkedin.com/in/dzagidulin/",
          company: "MIT Digital Credentials Consortium",
          companyURL: "https://digitalcredentials.mit.edu/",
          w3cid: 86708
        }],

        authors: [{
          name: "Dave Longley", url: "https://digitalbazaar.com/",
          company: "Digital Bazaar", companyURL: "https://digitalbazaar.com/",
          w3cid: 48025
        }, {
          name: "Manu Sporny", url: "https://www.linkedin.com/in/manusporny/",
          company: "Digital Bazaar", companyURL: "https://digitalbazaar.com/",
          w3cid: 41758
        }],

        github: "https://github.com/w3c/vc-di-eddsa/",

        // URI of the patent status for this WG, for Rec-track documents
        // !!!! IMPORTANT !!!!
        // This is important for Rec-track documents, do not copy a patent URI from a random
        // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
        // Team Contact.
        // wgPatentURI:  "",
        maxTocLevel: 4,
        /*preProcess: [ webpayments.preProcess ],
        alternateFormats: [ {uri: "diff-20111214.html", label: "diff to previous version"} ],
        */
        localBiblio: {
          MULTIBASE: {
            title: "Multibase",
            href: "https://datatracker.ietf.org/doc/html/draft-multiformats-multibase-01",
          },
          MULTICODEC: {
            title: "Multicodec",
            href: "https://github.com/multiformats/multicodec/",
          },
        },
        lint: {"no-unused-dfns": false},
        postProcess: [restrictRefs]
      };
    </script>
    <style>
      pre .highlight {
        font-weight: bold;
        color: green;
      }
      pre .comment {
        font-weight: bold;
        color: Gray;
      }
      .color-text {
        font-weight: bold;
        text-shadow: -1px 0 black, 0 1px black, 1px 0 black, 0 -1px black;
      }
      ol.algorithm {
        counter-reset: numsection;
        list-style-type: none;
      }
      ol.algorithm li {
        margin: 0.5em 0;
      }
      ol.algorithm li:before {
        font-weight: bold;
        counter-increment: numsection;
        content: counters(numsection, ".") ") ";
      }
    </style>
  </head>
  <body>
    <section id="abstract">
      <p>
This specification describes a Data Integrity cryptographic suite for use when
creating or verifying a digital signature using the twisted Edwards Curve
Digital Signature Algorithm (EdDSA) and Curve25519 (ed25519).
      </p>
    </section>

    <section id="sotd">
      <p>
This is an experimental specification and is undergoing regular revisions. It is
not fit for production deployment.
      </p>
    </section>

    <section>
      <h2>Introduction</h2>
      <p>
This specification defines a cryptographic suite for the purpose of creating,
verifying proofs for Ed25519 EdDSA signatures in conformance with the
Data Integrity [[VC-DATA-INTEGRITY]] specification. The approach is
accepted by the U.S. National Institute of Standards in the latest FIPS 186-5
publication and meets U.S. Federal Information Processing requirements when
using cryptography to secure digital information.
      </p>
      <p>
The suites described in this specification use the RDF Dataset Normalization
Algorithm [[RDF-CANON]] or the JSON Canonicalization Scheme [[RFC8785]] to
transform an input document into its canonical form. The canonical
representation is then hashed and signed with a detached signature algorithm.
      </p>

      <section id="terminology">
        <h3>Terminology</h3>

        <div data-include="https://w3c.github.io/vc-data-integrity/terms.html"></div>

      </section>

      <section id="conformance">
        <p>
A <dfn>conforming proof</dfn> is any concrete expression of the data model
that complies with the normative statements in this specification. Specifically,
all relevant normative statements in Sections
<a href="#data-model"></a> and <a href="#algorithms"></a>
of this document MUST be enforced.
        </p>

        <p>
A <dfn class="lint-ignore">conforming processor</dfn> is any algorithm realized
as software and/or hardware that generates or consumes a
<a>conforming proof</a>. Conforming processors MUST produce errors when
non-conforming documents are consumed.
        </p>
        <p>
This document also contains examples that contain JSON and JSON-LD content. Some
of these examples contain characters that are invalid JSON, such as inline
comments (`//`) and the use of ellipsis (`...`) to denote
information that adds little value to the example. Implementers are cautioned to
remove this content if they desire to use the information as valid JSON or
JSON-LD.
        </p>
      </section>

    </section>

    <section>
      <h2>Data Model</h2>

      <p>
The following sections outline the data model that is used by this specification
for verification methods and signature formats.
      </p>

      <section>
        <h3>Verification Methods</h3>
        <p>
The cryptographic material used to verify a linked data proof is called the
verification method. This suite relies on public key material represented using
[[MULTIBASE]] and [[MULTICODEC]]. This suite supports public key use for both
digital signature generation and verification, according to [[RFC8032]].
        </p>

        <p>
This suite MAY be used to verify Data Integrity Proofs [[VC-DATA-INTEGRITY]]
produced by Ed25519 public key material encoded as either a
<a href="#ed25519verificationkey2020">Ed25519VerificationKey2020</a> or
<a href="#multikey">Multikey</a>. Loss-less key transformation processes that
result in equivalent cryptographic material MAY be utilized.
        </p>

        <section>
          <h4>Multikey</h4>

          <p class="issue">
This definition should go in the Data Integrity specification and referenced
from there.
          </p>

          <p>
The `type` of the verification method MUST be `Multikey`.
          </p>

          <p>
The `controller` of the verification method MUST be a URL.
          </p>

          <p>
The `publicKeyMultibase` property of the verification method MUST be
a public key encoded according to [[MULTICODEC]] and formatted according to
[[MULTIBASE]]. The multicodec encoding of a Ed25519 public key is the two-byte
prefix `0xed01` followed by the 32-byte public key data. The 34 byte
value is then encoded using base58-btc (`z`) as the prefix. Any other encoding
MUST NOT be allowed.
          </p>

          <p class="advisement">
Developers are advised to not accidentally publish a representation of a private
key. Implementations of this specification will raise errors in the event of a
[[MULTICODEC]] value other than `0xed01` being used in a
`publicKeyMultibase` value.
          </p>

          <pre class="example"
            title="An Ed25519 public key encoded as a Multikey">
{
  "id": "https://example.com/issuer/123#key-0",
  "type": "Multikey",
  "controller": "https://example.com/issuer/123",
  "publicKeyMultibase": "z6Mkf5rGMoatrSj1f4CyvuHBeXJELe9RPdzo2PKGNCKVtZxP"
}
          </pre>

          <pre class="example" title="An Ed25519 public key encoded as a
            Multikey in a controller document">
{
  "@context": [
    "https://www.w3.org/ns/did/v1",
    "https://w3id.org/security/data-integrity/v1"
  ],
  "id": "did:example:123",
  "verificationMethod": [{
    "id": "did:example:123#key-0",
    "type": "Multikey",
    "controller": "did:example:123",
    "publicKeyMultibase": "z6Mkf5rGMoatrSj1f4CyvuHBeXJELe9RPdzo2PKGNCKVtZxP"
  }],
  "authentication": [
    "did:example:123#key-0"
  ],
  "assertionMethod": [
    "did:example:123#key-0"
  ],
  "capabilityDelegation": [
    "did:example:123#key-0"
  ],
  "capabilityInvocation": [
    "did:example:123#key-0"
  ]
}
          </pre>
        </section>

        <section>
          <h4>Ed25519VerificationKey2020</h4>

          <p class="issue">
We need to add documentation to note that this key format is deployed and
widely used in production, but is deprecated. `Multikey` and `JsonWebKey2020`
supersede it.
          </p>

          <p>
The `type` of the verification method MUST be
<a href="#ed25519verificationkey2020">Ed25519VerificationKey2020</a>.
          </p>

          <p>
The `controller` of the verification method MUST be a URL.
          </p>

          <p>
The `publicKeyMultibase` property of the verification method MUST be
a public key encoded according to [[MULTICODEC]] and formatted according to
[[MULTIBASE]]. The multicodec encoding of a Ed25519 public key is the two-byte
prefix `0xed01` followed by the 32-byte public key data. The 34 byte
value is then encoded using base58-btc (`z`) as the prefix. Any other encoding
MUST NOT be allowed.
          </p>

          <p class="advisement">
Developers are advised to not accidentally publish a representation of a private
key. Implementations of this specification will raise errors in the event of a
[[MULTICODEC]] value other than `0xed01` being used in a
`publicKeyMultibase` value.
          </p>

          <pre class="example" title="An Ed25519 public key encoded as an
            Ed25519VerificationKey2020">
{
  "id": "https://example.com/issuer/123#key-0",
  "type": "Ed25519VerificationKey2020",
  "controller": "https://example.com/issuer/123",
  "publicKeyMultibase": "z6Mkf5rGMoatrSj1f4CyvuHBeXJELe9RPdzo2PKGNCKVtZxP"
}
          </pre>

          <pre class="example" title="An Ed25519 public key encoded as an
            Ed25519VerificationKey2020 in a controller document.">
{
  "@context": [
    "https://www.w3.org/ns/did/v1",
    "https://w3id.org/security/suites/ed25519-2020/v1"
  ],
  "id": "did:example:123",
  "verificationMethod": [{
    "id": "did:example:123#key-0",
    "type": "Ed25519VerificationKey2020",
    "controller": "did:example:123",
    "publicKeyMultibase": "z6Mkf5rGMoatrSj1f4CyvuHBeXJELe9RPdzo2PKGNCKVtZxP"
  }],
  "authentication": [
    "did:example:123#key-0"
  ],
  "assertionMethod": [
    "did:example:123#key-0"
  ],
  "capabilityDelegation": [
    "did:example:123#key-0"
  ],
  "capabilityInvocation": [
    "did:example:123#key-0"
  ]
}
          </pre>
        </section>

      </section>

      <section>
        <h3>Proof Representations</h3>

        <p>
This suite relies on detached digital signatures represented using [[MULTIBASE]]
and [[MULTICODEC]].
        </p>

        <section>
          <h4>DataIntegrityProof</h4>

          <p>
The `verificationMethod` property of the proof MUST be a URL.
Dereferencing the `verificationMethod` MUST result in an object
containing a `type` property with the value set to
`Ed25519VerificationKey2020`.
          </p>

          <p>
The `type` property of the proof MUST be `DataIntegrityProof`.
          </p>
          <p>
The `cryptosuite` property of the proof MUST be `eddsa-2022`.
          </p>
          <p>
The `created` property of the proof MUST be an [[XMLSCHEMA11-2]]
formatted date string.
          </p>
          <p>
The `proofPurpose` property of the proof MUST be a string, and MUST
match the verification relationship expressed by the verification method
`controller`.
          </p>
          <p>
The `proofValue` property of the proof MUST be a detached EdDSA
produced according to [[RFC8032]], encoded according to [[MULTIBASE]] using
the base58-btc base encoding.
          </p>

          <pre class="example highlight" style="overflow-x:
            auto; white-space: pre-wrap; word-wrap: break-word;"
            title="An Ed25519 digital signature expressed as a
              DataIntegrityProof">
{
  "@context": [
    {"title": "https://schema.org/title"},
    "https://w3id.org/security/data-integrity/v1"
  ],
  "title": "Hello world!",
  "proof": {
    "type": "DataIntegrityProof",
    "cryptosuite": "eddsa-2022",
    "created": "2020-11-05T19:23:24Z",
    "verificationMethod": "https://ldi.example/issuer#z6MkjLrk3gKS2nnkeWcmcxi
      ZPGskmesDpuwRBorgHxUXfxnG",
    "proofPurpose": "assertionMethod",
    "proofValue": "z4oey5q2M3XKaxup3tmzN4DRFTLVqpLMweBrSxMY2xHX5XTYVQeVbY8nQA
      VHMrXFkXJpmEcqdoDwLWxaqA3Q1geV6"
  }
}
          </pre>

        </section>

        <section>
          <h4>Ed25519Signature2020</h4>

          <p>
The `verificationMethod` property of the proof MUST be a URL.
Dereferencing the `verificationMethod` MUST result in an object
containing a `type` property with the value set to
`Ed25519VerificationKey2020`.
          </p>

          <p>
The `type` property of the proof MUST be `Ed25519Signature2020`.
          </p>
          <p>
The `created` property of the proof MUST be an [[XMLSCHEMA11-2]]
formatted date string.
          </p>
          <p>
The `proofPurpose` property of the proof MUST be a string, and MUST
match the verification relationship expressed by the verification method
`controller`.
          </p>
          <p>
The `proofValue` property of the proof MUST be a detached EdDSA
produced according to [[RFC8032]], encoded according to [[MULTIBASE]] using
the base58-btc base encoding.
          </p>

          <pre class="example highlight" style="overflow-x:
            auto; white-space: pre-wrap; word-wrap: break-word;"
            title="An Ed25519 digital signature expressed as a
            Ed25519Signature2020">
{
  "@context": [
    {"title": "https://schema.org/title"},
    "https://w3id.org/security/data-integrity/v1"
  ],
  "title": "Hello world!",
  "proof": {
    "type": "Ed25519Signature2020",
    "created": "2020-11-05T19:23:24Z",
    "verificationMethod": "https://di.example/issuer#z6MkjLrk3gKS2nnkeWcmcxi
      ZPGskmesDpuwRBorgHxUXfxnG",
    "proofPurpose": "assertionMethod",
    "proofValue": "z4oey5q2M3XKaxup3tmzN4DRFTLVqpLMweBrSxMY2xHX5XTYVQeVbY8nQA
      VHMrXFkXJpmEcqdoDwLWxaqA3Q1geV6"
  }
}
          </pre>

        </section>
      </section>
    </section>

    <section>
      <h2>Algorithms</h2>

      <p>
The following section describes multiple Data Integrity cryptographic suites
that utilize the twisted Edwards Curve Digital Signature Algorithm.
      </p>

      <section>
        <h3>eddsa-2022</h3>

        <p>
The `eddsa-2022` cryptographic suite takes an input document, canonicalizes
the document using the Universal RDF Dataset Canonicalization Algorithm
[[RDF-CANON]], and then cryptographically hashes and signs the output
resulting in the production of a data integrity proof. The algorithms in this
section also include the verification of such a data integrity proof.
        </p>

        <section>
          <h4>Add Proof (eddsa-2022)</h4>

          <p>
To generate a proof, the algorithm in
<a data-cite="vc-data-integrity#add-proof">
Section 4.1: Add Proof</a> in the Data Integrity
[[VC-DATA-INTEGRITY]] specification MUST be executed.
For that algorithm, the cryptographic suite specific
<a data-cite="vc-data-integrity#dfn-transformation-algorithm">
transformation algorithm</a> is defined in Section
<a href="#transformation-eddsa-2022"></a>, the
<a data-cite="vc-data-integrity#dfn-hashing-algorithm">
hashing algorithm</a> is defined in Section <a href="#hashing-eddsa-2022"></a>,
and the
<a data-cite="vc-data-integrity#dfn-proof-serialization-algorithm">
proof serialization algorithm</a> is defined in Section
<a href="#proof-serialization-eddsa-2022"></a>.
          </p>
        </section>

        <section>
          <h4>Verify Proof (eddsa-2022)</h4>

          <p>
To verify a proof, the algorithm in
<a data-cite="vc-data-integrity#verify-proof">
Section 4.2: Verify Proof</a> in the Data Integrity
[[VC-DATA-INTEGRITY]] specification MUST be executed.
For that algorithm, the cryptographic suite specific
<a data-cite="vc-data-integrity#dfn-transformation-algorithm">
transformation algorithm</a> is defined in Section
<a href="#transformation-eddsa-2022"></a>, the
<a data-cite="vc-data-integrity#dfn-hashing-algorithm">
hashing algorithm</a> is defined in Section <a href="#hashing-eddsa-2022"></a>,
and the
<a data-cite="vc-data-integrity#dfn-proof-serialization-algorithm">
proof verification algorithm</a> is defined in Section
<a href="#proof-verification-eddsa-2022"></a>.
          </p>
        </section>

        <section>
          <h4>Transformation (eddsa-2022)</h4>

          <p>
The following algorithm specifies how to transform an unsecured input document
into a transformed document that is ready to be provided as input to the
hashing algorithm in Section <a href="#hashing-eddsa-2022"></a>.
          </p>

          <p>
Required inputs to this algorithm are an
<a data-cite="vc-data-integrity#dfn-unsecured-data-document">
unsecured data document</a> (<var>unsecuredDocument</var>) and
transformation options (<var>options</var>). The
transformation options MUST contain a type identifier for the
<a data-cite="vc-data-integrity#dfn-cryptosuite">
cryptographic suite</a> (<var>type</var>) and a cryptosuite
identifier (<var>cryptosuite</var>). A <em>transformed data document</em> is
produced as output. Whenever this algorithm encodes strings, it MUST use UTF-8
encoding.
          </p>

          <ol class="algorithm">
            <li>
If <var>options</var>.<var>type</var> is not set to the string
`DataIntegrityProof` and <var>options</var>.<var>cryptosuite</var> is not
set to the string `eddsa-2020` then a `PROOF_TRANSFORMATION_ERROR` MUST be
raised.
            </li>
            <li>
Let <var>canonicalDocument</var> be the result of applying the
Universal RDF Dataset Canonicalization Algorithm
[[RDF-CANON]] to the <var>unsecuredDocument</var>.
            </li>
            <li>
Return <var>canonicalDocument</var> as the <em>transformed data document</em>.
            </li>
          </ol>
        </section>

        <section>
          <h4>Hashing (eddsa-2022)</h4>

          <p>
The following algorithm specifies how to cryptographically hash a
<em>transformed data document</em> and <em>proof configuration</em>
into cryptographic hash data that is ready to be provided as input to the
algorithms in Section <a href="#proof-serialization-eddsa-2022"></a> or
Section <a href="#proof-verification-eddsa-2022"></a>.
          </p>

          <p>
The required inputs to this algorithm are a <em>transformed data document</em>
(<var>transformedDocument</var>) and <em>canonical proof configuration</em>
(<var>canonicalProofConfig</var>). A single <em>hash data</em> value represented as
series of bytes is produced as output.
          </p>

          <ol class="algorithm">
            <li>
Let <var>transformedDocumentHash</var> be the result of applying the
SHA-256 (SHA-2 with 256-bit output) cryptographic hashing algorithm [[RFC6234]]
to the <var>transformedDocument</var>. <var>transformedDocumentHash</var> will
be exactly 32 bytes in size.
            </li>
            <li>
Let <var>proofConfigHash</var> be the result of applying the
SHA-256 (SHA-2 with 256-bit output) cryptographic hashing algorithm [[RFC6234]]
to the <var>canonicalProofConfig</var>. <var>proofConfigHash</var> will be
exactly 32 bytes in size.
            </li>
            <li>
Let <var>hashData</var> be the result of joining <var>proofConfigHash</var> (the
first hash) with <var>transformedDocumentHash</var> (the second hash).
            </li>
            <li>
Return <var>hashData</var> as the <em>hash data</em>.
            </li>
          </ol>

        </section>

        <section>
          <h4>Proof Configuration (eddsa-2022)</h4>

          <p>
The following algorithm specifies how to generate a
<em>proof configuration</em> from a set of <em>proof options</em>
that is used as input to the <a href="#hashing-eddsa-2022">proof hashing algorithm</a>.
          </p>

          <p>
The required inputs to this algorithm are <em>proof options</em>
(<var>options</var>). The <em>proof options</em> MUST contain a type identifier
for the
<a data-cite="vc-data-integrity#dfn-cryptosuite">
cryptographic suite</a> (<var>type</var>) and MUST contain a cryptosuite
identifier (<var>cryptosuite</var>). A <em>proof configuration</em>
object is produced as output.
          </p>

          <ol class="algorithm">
            <li>
Let <var>proofConfig</var> be an empty object.
            </li>
            <li>
Set <var>proofConfig</var>.<var>type</var> to
<var>options</var>.<var>type</var>.
            </li>
            <li>
If <var>options</var>.<var>cryptosuite</var> is set, set
<var>proofConfig</var>.<var>cryptosuite</var> to its value.
            </li>
            <li>
If <var>options</var>.<var>type</var> is not set to `DataIntegrityProof` and
<var>proofConfig</var>.<var>cryptosuite</var> is not set to `eddsa-2020`, an
`INVALID_PROOF_CONFIGURATION` error MUST be raised.
            </li>
            <li>
Set <var>proofConfig</var>.<var>created</var> to
<var>options</var>.<var>created</var>. If the value is not a valid
[[XMLSCHEMA11-2]] datetime, an `INVALID_PROOF_DATETIME` error MUST be raised.
            </li>
            <li>
Set <var>proofConfig</var>.<var>verificationMethod</var> to
<var>options</var>.<var>verificationMethod</var>.
            </li>
            <li>
Set <var>proofConfig</var>.<var>proofPurpose</var> to
<var>options</var>.<var>proofPurpose</var>.
            </li>
            <li>
Set <var>proofConfig</var>.<var>@context</var> to
<var>unsecuredDocument</var>.<var>@context</var>
            </li>
            <li>
Let <var>canonicalProofConfig</var> be the result of applying the
Universal RDF Dataset Canonicalization Algorithm
[[RDF-CANON]] to the <var>proofConfig</var>.
            </li>
            <li>
Return <var>canonicalProofConfig</var>.
            </li>
          </ol>

        </section>

        <section>
          <h4>Proof Serialization (eddsa-2022)</h4>

          <p>
The following algorithm specifies how to serialize a digital signature from
a set of cryptographic hash data. This
algorithm is designed to be used in conjunction with the algorithms defined
in the Data Integrity [[VC-DATA-INTEGRITY]] specification,
<a data-cite="vc-data-integrity#algorithms">
Section 4: Algorithms</a>. Required inputs are
cryptographic hash data (<var>hashData</var>) and
<em>proof options</em> (<var>options</var>). The
<em>proof options</em> MUST contain a type identifier for the
<a data-cite="vc-data-integrity#dfn-cryptosuite">
cryptographic suite</a> (<var>type</var>) and MAY contain a cryptosuite
identifier (<var>cryptosuite</var>). A single <em>digital proof</em> value
represented as series of bytes is produced as output.
          </p>

          <ol class="algorithm">
            <li>
Let <var>privateKeyBytes</var> be the result of retrieving the
private key bytes associated with the
<var>options</var>.<var>verificationMethod</var> value as described in the
Data Integrity [[VC-DATA-INTEGRITY]] specification,
<a data-cite="vc-data-integrity#algorithms">
Section 4: Retrieving Cryptographic Material</a>.
            </li>
            <li>
Let <var>proofBytes</var> be the result of applying the Edwards-Curve Digital
Signature Algorithm (EdDSA) [[RFC8032]], using the `Ed25519` variant
(Pure EdDSA), with <var>hashData</var> as the data to be signed using
the private key specified by <var>privateKeyBytes</var>.
<var>proofBytes</var> will be exactly 64 bytes in size.
            </li>
            <li>
Return <var>proofBytes</var> as the <em>digital proof</em>.
            </li>
          </ol>

        </section>

        <section>
          <h4>Proof Verification (eddsa-2022)</h4>

          <p>
The following algorithm specifies how to verify a digital signature from
a set of cryptographic hash data. This
algorithm is designed to be used in conjunction with the algorithms defined
in the Data Integrity [[VC-DATA-INTEGRITY]] specification,
<a data-cite="vc-data-integrity#algorithms">
Section 4: Algorithms</a>. Required inputs are
cryptographic hash data (<var>hashData</var>),
a digital signature (<var>proofBytes</var>) and
proof options (<var>options</var>). A <em>verification result</em>
represented as a boolean value is produced as output.
          </p>

          <ol class="algorithm">
            <li>
Let <var>publicKeyBytes</var> be the result of retrieving the
public key bytes associated with the
<var>options</var>.<var>verificationMethod</var> value as described in the
Data Integrity [[VC-DATA-INTEGRITY]] specification,
<a data-cite="vc-data-integrity#algorithms">
Section 4: Retrieving Cryptographic Material</a>.
            </li>
            <li>
Let <var>verificationResult</var> be the result of applying the verification
algorithm for the Edwards-Curve Digital Signature Algorithm (EdDSA)
[[RFC8032]], using the `Ed25519` variant (Pure EdDSA),
with <var>hashData</var> as the data to be verified against the
<var>proofBytes</var> using the public key specified by
<var>publicKeyBytes</var>.
            </li>
            <li>
Return <var>verificationResult</var> as the <em>verification result</em>.
            </li>
          </ol>

        </section>
      </section>

      <section>
        <h3>jcs-eddsa-2022</h3>

          <p class="issue" title="Cryptosuite naming convention is disputed">
The naming convention utilized by this cryptosuite is disputed. An alternative
of `json-eddsa-2022` was originally suggested for this cryptography suite to
convey that it is a cryptography suite for securing JSON data utilizing the
Twisted Edwards Curve Digital Signature Algorithm. The counter-argument to
the original proposal was that expressing the canonicalization mechanism in
the cryptosuite string clearly conveys to a developer that the thing that
differentiates this cryptosuite from the `eddsa-2022` one is the use of
JSON Canonicalization Scheme [[RFC8785]]. Other options include
`"cryptosuite": "json-sign-2022"`, and `"cryptosuite": "json-2022"`. This
topic is <a href="https://github.com/w3c/vc-data-integrity/issues/38">
currently being debated in the Data Integrity work item.</a>.
          </p>

          <p>
The `jcs-eddsa-2022` cryptographic suite takes an input document, canonicalizes
the document using the JSON Canonicalization Scheme [[RFC8785]], and then
cryptographically hashes and signs the output resulting in the production of a
data integrity proof. The algorithms for this cryptographic suite are the
same as the ones in Section <a href="#eddsa-2022"></a> except for the following
modifications:
          </p>

          <p>
In Section <a href="#transformation-eddsa-2022"></a>, step <strong>1)</strong>
and step <strong>2)</strong> are replaced by the following text:
          </p>

          <ol class="algorithm">
            <li>
If <var>options</var>.<var>type</var> is not set to the string
`DataIntegrityProof` and <var>options</var>.<var>cryptosuite</var> is not
set to the string `jcs-eddsa-2022` then a `PROOF_TRANSFORMATION_ERROR` MUST be
raised.
            </li>
            <li>
Let <var>canonicalDocument</var> be the result of applying the
JSON Canonicalization Scheme [[RFC8785]] to the <var>unsecuredDocument</var>.
            </li>
          </ol>

          <p>
In Section <a href="#proof-configuration-eddsa-2022"></a>, step
<strong>4)</strong> is replaced by the following text:
          </p>

          <p style="padding-left: 2em;">
<strong>4)</strong> If <var>options</var>.<var>type</var> is not set to
`DataIntegrityProof` and <var>proofConfig</var>.<var>cryptosuite</var> is not
set to `json-eddsa-2020`, an `INVALID_PROOF_CONFIGURATION` error MUST be raised.
          </p>
      </section>

      <section>
        <h3>Ed25519Signature2020</h3>

        <p>
The `Ed25519Signature2020` cryptographic suite takes an input document,
canonicalizes the document using the Universal RDF Dataset Canonicalization
Algorithm [[RDF-CANON]], and then cryptographically hashes and signs the output
resulting in the production of a data integrity proof. The algorithms in this
section also include the verification of such a data integrity proof.
        </p>

        <section>
          <h4>Add Proof (Ed25519Signature2020)</h4>

          <p>
To generate a proof, the algorithm in
<a data-cite="vc-data-integrity#add-proof">
Section 4.1: Add Proof</a> in the Data Integrity
[[VC-DATA-INTEGRITY]] specification MUST be executed.
For that algorithm, the cryptographic suite specific
<a data-cite="vc-data-integrity#dfn-transformation-algorithm">
transformation algorithm</a> is defined in Section
<a href="#transformation-ed25519signature2020"></a>, the
<a data-cite="vc-data-integrity#dfn-hashing-algorithm">
hashing algorithm</a> is defined in Section <a href="hashing-ed25519signature2020"></a>,
and the
<a data-cite="vc-data-integrity#dfn-proof-serialization-algorithm">
proof serialization algorithm</a> is defined in Section
<a href="#proof-serialization-ed25519signature2020"></a>.
          </p>
        </section>

        <section>
          <h4>Verify Proof (Ed25519Signature2020)</h4>

          <p>
To verify a proof, the algorithm in
<a data-cite="vc-data-integrity#verify-proof">
Section 4.2: Verify Proof</a> in the Data Integrity
[[VC-DATA-INTEGRITY]] specification MUST be executed.
For that algorithm, the cryptographic suite specific
<a data-cite="vc-data-integrity#dfn-transformation-algorithm">
transformation algorithm</a> is defined in Section
<a href="#transformation-ed25519signature2020"></a>, the
<a data-cite="vc-data-integrity#dfn-hashing-algorithm">
hashing algorithm</a> is defined in Section <a href="#hashing-ed25519signature2020"></a>,
and the
<a data-cite="vc-data-integrity#dfn-proof-serialization-algorithm">
proof verification algorithm</a> is defined in Section
<a href="#proof-verification-ed25519signature2020"></a>.
          </p>
        </section>

        <section>
          <h4>Transformation (Ed25519Signature2020)</h4>

          <p>
The following algorithm specifies how to transform an unsecured input document
into a transformed document that is ready to be provided as input to the
hashing algorithm in Section <a href="#hashing-ed25519signature2020"></a>.
          </p>

          <p>
Required inputs to this algorithm are an
<a data-cite="vc-data-integrity#dfn-unsecured-data-document">
unsecured data document</a> (<var>unsecuredDocument</var>) and
transformation options (<var>options</var>). The
transformation options MUST contain a type identifier for the
<a data-cite="vc-data-integrity#dfn-cryptosuite">
cryptographic suite</a> (<var>type</var>) and a cryptosuite
identifier (<var>cryptosuite</var>). A <em>transformed data document</em> is
produced as output. Whenever this algorithm encodes strings, it MUST use UTF-8
encoding.
          </p>

          <ol class="algorithm">
            <li>
If <var>options</var>.<var>type</var> is not set to the string
`Ed25519Signature2020`, then a `PROOF_TRANSFORMATION_ERROR` MUST be raised.
            </li>
            <li>
Let <var>canonicalDocument</var> be the result of applying the
Universal RDF Dataset Canonicalization Algorithm
[[RDF-CANON]] to the <var>unsecuredDocument</var>.
            </li>
            <li>
Set <var>output</var> to the value of <var>canonicalDocument</var>.
            </li>
            <li>
Return <var>canonicalDocument</var> as the <em>transformed data document</em>.
            </li>
          </ol>

        </section>

        <section>
          <h4>Hashing (Ed25519Signature2020)</h4>

          <p>
The following algorithm specifies how to cryptographically hash a
<em>transformed data document</em> and <em>proof configuration</em>
into cryptographic hash data that is ready to be provided as input to the
algorithms in Section <a href="#proof-serialization-ed25519signature2020"></a> or
Section <a href="#proof-verification-ed25519signature2020"></a>.
          </p>

          <p>
The required inputs to this algorithm are a
<em>transformed data document</em> (<var>transformedDocument</var>) and
<em>proof configuration</em> (<var>proofConfig</var>). The
<em>proof configuration</em> MUST contain a type identifier for the
<a data-cite="vc-data-integrity#dfn-cryptosuite">
cryptographic suite</a> (<var>type</var>) and MAY contain a cryptosuite
identifier (<var>cryptosuite</var>). A single <em>hash data</em> value
represented as series of bytes is produced as output.
          </p>

          <ol class="algorithm">
            <li>
Let <var>transformedDocumentHash</var> be the result of applying the
SHA-256 (SHA-2 with 256-bit output) cryptographic hashing algorithm [[RFC6234]]
to the <var>transformedDocument</var>. <var>transformedDocumentHash</var> will
be exactly 32 bytes in size.
            </li>
            <li>
Let <var>proofConfigHash</var> be the result of applying the
SHA-256 (SHA-2 with 256-bit output) cryptographic hashing algorithm [[RFC6234]]
to the <var>proofConfig</var>. <var>proofConfigHash</var> will be
exactly 32 bytes in size.
            </li>

            <li>
Let <var>hashData</var> be the result of joining <var>proofConfigHash</var> (the
first hash) with <var>transformedDocumentHash</var> (the second hash).
            </li>
            <li>
Return <var>hashData</var> as the <em>hash data</em>.
            </li>
          </ol>

        </section>

        <section>
          <h4>Proof Configuration (Ed25519Signature2020)</h4>

          <p>
The following algorithm specifies how to generate a
<em>proof configuration</em> from a set of <em>proof options</em>
that is used as input to the <a href="#hashing-ed25519signature2020">proof hashing algorithm</a>.
          </p>

          <p>
The required inputs to this algorithm are <em>proof options</em>
(<var>options</var>). The <em>proof options</em> MUST contain a type identifier
for the
<a data-cite="vc-data-integrity#dfn-cryptosuite">
cryptographic suite</a> (<var>type</var>) and MAY contain a cryptosuite
identifier (<var>cryptosuite</var>). A <em>proof configuration</em>
object is produced as output.
          </p>

          <ol class="algorithm">
            <li>
Let <var>proofConfig</var> be an empty object.
            </li>
            <li>
Set <var>proofConfig</var>.<var>type</var> to
<var>options</var>.<var>type</var>.
            </li>
            <li>
If <var>options</var>.<var>cryptosuite</var> is set, set
<var>proofConfig</var>.<var>cryptosuite</var> to its value.
            </li>
            <li>
If <var>options</var>.<var>type</var> is not set to `Ed25519Signature2020`, an
`INVALID_PROOF_CONFIGURATION` error MUST be raised.
            </li>
            <li>
Set <var>proofConfig</var>.<var>created</var> to
<var>options</var>.<var>created</var>. If the value is not a valid
[[XMLSCHEMA11-2]] datetime, an `INVALID_PROOF_DATETIME` error MUST be raised.
            </li>
            <li>
Set <var>proofConfig</var>.<var>verificationMethod</var> to
<var>options</var>.<var>verificationMethod</var>.
            </li>
            <li>
Set <var>proofConfig</var>.<var>proofPurpose</var> to
<var>options</var>.<var>proofPurpose</var>.
            </li>
            <li>
Return <var>proofConfig</var>.
            </li>
          </ol>

        </section>

        <section>
          <h4>Proof Serialization (Ed25519Signature2020)</h4>

          <p>
The following algorithm specifies how to serialize a digital signature from
a set of cryptographic hash data. This
algorithm is designed to be used in conjunction with the algorithms defined
in the Data Integrity [[VC-DATA-INTEGRITY]] specification,
<a data-cite="vc-data-integrity#algorithms">
Section 4: Algorithms</a>. Required inputs are
cryptographic hash data (<var>hashData</var>) and
<em>proof options</em> (<var>options</var>). The
<em>proof options</em> MUST contain a type identifier for the
<a data-cite="vc-data-integrity#dfn-cryptosuite">
cryptographic suite</a> (<var>type</var>) and MAY contain a cryptosuite
identifier (<var>cryptosuite</var>). A single <em>digital proof</em> value
represented as series of bytes is produced as output.
          </p>

          <ol class="algorithm">
            <li>
Let <var>privateKeyBytes</var> be the result of retrieving the
private key bytes associated with the
<var>options</var>.<var>verificationMethod</var> value as described in the
Data Integrity [[VC-DATA-INTEGRITY]] specification,
<a data-cite="vc-data-integrity#algorithms">
Section 4: Retrieving Cryptographic Material</a>.
            </li>
            <li>
Let <var>proofBytes</var> be the result of applying the Edwards-Curve Digital
Signature Algorithm (EdDSA) [[RFC8032]], using the `Ed25519` variant
(Pure EdDSA), with <var>hashData</var> as the data to be signed using
the private key specified by <var>privateKeyBytes</var>.
<var>proofBytes</var> will be exactly 64 bytes in size.
            </li>
            <li>
Return <var>proofBytes</var> as the <em>digital proof</em>.
            </li>
          </ol>

        </section>

        <section>
          <h4>Proof Verification (Ed25519Signature2020)</h4>

          <p>
The following algorithm specifies how to verify a digital signature from
a set of cryptographic hash data. This
algorithm is designed to be used in conjunction with the algorithms defined
in the Data Integrity [[VC-DATA-INTEGRITY]] specification,
<a data-cite="vc-data-integrity#algorithms">
Section 4: Algorithms</a>. Required inputs are
cryptographic hash data (<var>hashData</var>),
a digital signature (<var>proofBytes</var>) and
proof options (<var>options</var>). A <em>verification result</em>
represented as a boolean value is produced as output.
          </p>

          <ol class="algorithm">
            <li>
Let <var>publicKeyBytes</var> be the result of retrieving the
public key bytes associated with the
<var>options</var>.<var>verificationMethod</var> value as described in the
Data Integrity [[VC-DATA-INTEGRITY]] specification,
<a data-cite="vc-data-integrity#algorithms">
Section 4: Retrieving Cryptographic Material</a>.
            </li>
            <li>
Let <var>verificationResult</var> be the result of applying the verification
algorithm for the Edwards-Curve Digital Signature Algorithm (EdDSA)
[[RFC8032]], using the `Ed25519` variant (Pure EdDSA),
with <var>hashData</var> as the data to be verified against the
<var>proofBytes</var> using the public key specified by
<var>publicKeyBytes</var>.
            </li>
            <li>
Return <var>verificationResult</var> as the <em>verification result</em>.
            </li>
          </ol>

        </section>
      </section>
    </section>

    <section>
      <h2>Security Considerations</h2>
      <p>
The following section describes security considerations that developers
implementing this specification should be aware of in order to create secure
software.
      </p>

      <p class="note">
This specification relies on URDNA2015, please review
[[RDF-CANON]].
      </p>

      <p class="note">
This specification relies on [[MULTIBASE]], [[MULTICODEC]] and [[RFC8032]].
      </p>

      <p class="issue">
There are <a href="https://eprint.iacr.org/2020/1244.pdf">
known mis-implementation attacks against multiple flavors of EdDSA</a>
implementations. We might want to warn about what to look out for and how to
mitigate the attacks.
      </p>

    </section>

    <section>
      <h2>Privacy Considerations</h2>
      <p>
The following section describes privacy considerations that developers
implementing this specification should be aware of in order to avoid violating
privacy assumptions.
      </p>

      <p class="issue">
This cryptography suite does not provide for selective disclosure or
unlinkability. If signatures are re-used, they can be used as correlatable data.
      </p>
    </section>

    <section class="appendix">
      <h2>Test Vectors</h2>
      <section>
        <h3>Representation: Ed25519Signature2020</h3>
        <p>
The signer needs to generate a private/public key pair with the private key used
for signing and the public key made available for verification. The
[[MULTIBASE]]/[[MULTICODEC]] representation for the public key, <code>ed25519-pub</code>,
and the representation for the private key, <code>ed25519-priv</code>, are shown below.
        </p>
        <pre class="example" title="Private and Public keys for Signature">
{
    publicKeyMultibase: "z6MkrJVnaZkeFzdQyMZu1cgjg7k1pZZ6pvBQ7XJPt4swbTQ2",
    privateKeyMultibase: "z3u2en7t5LR2WtQH5PfFqMqwVHBeXouLzo6haApm8XHqvjxq"
}
        </pre>

        <p>
Signing begins with a credential without an attached proof, which is converted
to canonical form, and then hashed, as shown in the following three examples.
        </p>

        <pre class="example" title="Credential without Proof">
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1",
    "https://w3id.org/security/suites/ed25519-2020/v1"
  ],
  "id": "http://example.edu/credentials/3732",
  "type": [
    "VerifiableCredential",
    "UniversityDegreeCredential"
  ],
  "issuer": "https://example.edu/issuers/565049",
  "issuanceDate": "2010-01-01T00:00:00Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "BachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  }
}
        </pre>

        <pre class="example" title="Canonical Credential without Proof">
          &lt;did:example:ebfeb1f712ebc6f1c276e12ec21&gt; &lt;https://example.org/examples#degree&gt; _:c14n0 .
          &lt;http://example.edu/credentials/3732&gt; &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt; &lt;https://example.org/examples#UniversityDegreeCredential&gt; .
          &lt;http://example.edu/credentials/3732&gt; &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt; &lt;https://www.w3.org/2018/credentials#VerifiableCredential&gt; .
          &lt;http://example.edu/credentials/3732&gt; &lt;https://www.w3.org/2018/credentials#credentialSubject&gt; &lt;did:example:ebfeb1f712ebc6f1c276e12ec21&gt; .
          &lt;http://example.edu/credentials/3732&gt; &lt;https://www.w3.org/2018/credentials#issuanceDate&gt; &quot;2010-01-01T00:00:00Z&quot;^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt; .
          &lt;http://example.edu/credentials/3732&gt; &lt;https://www.w3.org/2018/credentials#issuer&gt; &lt;https://example.edu/issuers/565049&gt; .
          _:c14n0 &lt;http://schema.org/name&gt; &quot;Bachelor of Science and Arts&quot;^^&lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#HTML&gt; .
          _:c14n0 &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt; &lt;https://example.org/examples#BachelorDegree&gt; .
        </pre>

        <pre class="example" title="Hash of Canonical Credential without Proof (hex)">
6c6b2795e7fa33a9fb28062527142b3c6edf7ba239942439b6f0bb0851b3cce3
        </pre>

        <p>
The next step is to take the proof options document, convert it to canonical form,
and obtain its hash, as shown in the next three examples.
        </p>

        <pre class="example" title="Proof Options Document">
{
  "type": "Ed25519Signature2020",
  "created": "2022-12-07T21:31:08Z",
  "verificationMethod": "https://example.edu/issuers/565049#key-1",
  "proofPurpose": "assertionMethod",
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1",
    "https://w3id.org/security/suites/ed25519-2020/v1"
  ]
}
        </pre>

        <pre class="example" title="Canonical Proof Options Document">
_:c14n0 &lt;http://purl.org/dc/terms/created&gt; &quot;2022-12-07T21:31:08Z&quot;^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt; .
_:c14n0 &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt; &lt;https://w3id.org/security#Ed25519Signature2020&gt; .
_:c14n0 &lt;https://w3id.org/security#proofPurpose&gt; &lt;https://w3id.org/security#assertionMethod&gt; .
_:c14n0 &lt;https://w3id.org/security#verificationMethod&gt; &lt;https://example.edu/issuers/565049#key-1&gt; .
        </pre>

        <pre class="example" title="Hash of Canonical Proof Options Document (hex)">
565a2884ebb2d38aa34871108074ab51631ec812d33eb2473178bce19937ad09
        </pre>

        <p>
Finally, we combine the two hashes, use the private key with the combined hash to
compute the Ed25519 signature, and then base58-btc encode the signature.
        </p>

        <pre class="example" title="Combine hashes of Proof Options and Credential (hex)">
565a2884ebb2d38aa34871108074ab51631ec812d33eb2473178bce19937ad096c6b2795e7fa33a9fb28062527142b3c6edf7ba239942439b6f0bb0851b3cce3
        </pre>

        <pre class="example" title="Signature of Combined Hashes (hex)">
473fb02a4aaf5863a2ef33f104bd55617e40907bc311e29e87278d15d7596f201639f41ec0e00db11159e9139f673d9257558e1f0134e1f67ac73f91ed89670b
        </pre>

        <pre class="example" title="Signature of Combined Hashes base58-btc">
z2RczMj342tVhAjgjEPV4TeHbi2ggnTRKTc5BFQCgaWJ3nhcg5HgCeC2eV4Lc1fYdhfoLyPjxoq4BtqrsyNvxZ8nE
        </pre>

        <p>Assemble the signed credential with the following two steps:</p>
        <ol>
          <li>
Add the <code>proofValue</code> field with the previously computed base58-btc
value to the proof options document.
          </li>
          <li>
Set the <code>proof</code> field of the credential to the augmented proof
option document.
          </li>
        </ol>

        <pre class="example" title="Signed Credential">
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1",
    "https://w3id.org/security/suites/ed25519-2020/v1"
  ],
  "id": "http://example.edu/credentials/3732",
  "type": [
    "VerifiableCredential",
    "UniversityDegreeCredential"
  ],
  "issuer": "https://example.edu/issuers/565049",
  "issuanceDate": "2010-01-01T00:00:00Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "BachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  "proof": {
    "type": "Ed25519Signature2020",
    "created": "2022-12-07T21:31:08Z",
    "verificationMethod": "https://example.edu/issuers/565049#key-1",
    "proofPurpose": "assertionMethod",
    "proofValue": "z2RczMj342tVhAjgjEPV4TeHbi2ggnTRKTc5BFQCgaWJ3nhcg5HgCeC2eV4Lc1fYdhfoLyPjxoq4BtqrsyNvxZ8nE"
  }
}
        </pre>

      </section>
    </section>

  </body>
</html>
